<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <link rel="manifest" href="manifest.json">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">

    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Biome Mapper">

    <link rel="apple-touch-icon" href="images/favicon.ico">
    <link rel="icon" href="images/favicon.ico" type="image/x-icon" />

    <title>Helldivers 2 Biome Mapper</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes" />
    <style>
        body {
            margin: 0;
            display: flex;
            font-family: sans-serif;
            background: #111;
            color: white;
            height: 100vh;
            overflow: hidden;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
        }

        #planetCanvas {
            flex: 1 1 auto;
            background-color: #000;
            display: block;
            width: 100%;
            height: 100vh;
            cursor: grab;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        #biomeList {
            width: 380px;
            height: 100vh;
            overflow-y: auto;
            background-color: #222;
            padding: 10px;
            box-sizing: border-box;
        }

        .biome {
            position: relative;
            margin-bottom: 10px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.2s, border 0.2s;
            border: 2px solid transparent;
            border-radius: 5px;
            user-select: none;
        }

        .biome img {
            width: 100%;
            border-radius: 5px;
            display: block;
        }

        .biome.selected {
            opacity: 1;
            border-color: #0ff;
        }

        .hippo-dots {
            position: absolute;
            top: 6px;
            right: 6px;
            display: flex;
            gap: 3px;
        }

        .hippo-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: grey;
        }

        .hippo-dot.yellow {
            background-color: yellow;
        }

        .biome .hover-name {
            position: absolute;
            bottom: 6px;
            right: 8px;
            color: yellow;
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
            user-select: none;
            display: none;
            text-shadow: 0 0 3px black;
            white-space: nowrap;
        }

        .biome:not(.selected):hover .hover-name {
            display: block;
        }

        .biome.selected .hover-name {
            display: block;
        }

        .toggle-wrapper {
            position: absolute;
            top: 6px;
            left: 6px;
            display: flex;
            align-items: center;
            user-select: none;
            pointer-events: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .toggle {
            width: 32px;
            height: 18px;
            background-color: #888;
            border-radius: 9px;
            position: relative;
            transition: background-color 0.3s ease;
            flex-shrink: 0;
        }

        .toggle.on {
            background-color: #f9d71c;
            box-shadow: 0 0 6px 1px #f9d71c99;
        }

        .toggle-circle {
            width: 14px;
            height: 14px;
            background-color: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: left 0.3s ease;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
        }

        .toggle.on .toggle-circle {
            left: 16px;
            background-color: #fff842;
            box-shadow: 0 0 6px #f9d71c;
        }

        .toggle,
        .toggle-circle {
            pointer-events: none;
        }
    </style>
</head>

<body>

    <canvas id="planetCanvas"></canvas>
    <div id="biomeList"></div>

    <script>
        const devmode = false;

        const sidebarWidth = 380;
        const canvas = document.getElementById("planetCanvas");
        const ctx = canvas.getContext("2d");

        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;

        let isDragging = false;
        let dragStartX, dragStartY;

        function updateCanvasSize() {
            const width = window.innerWidth - sidebarWidth;
            const height = window.innerHeight;

            canvas.width = width;
            canvas.height = height;

            canvas.style.width = width + "px";
            canvas.style.height = height + "px";
        }

        updateCanvasSize();
        window.addEventListener('resize', () => {
            updateCanvasSize();
            clampOffset();
            drawPlanets();
        });

        let allPlanets = [];
        let playablePlanetsSet = new Set();
        let selectedBiome = null;
        const planetRadius = 8;
        let hoveredPlanet = null;

        const backgroundImg = new Image();
        backgroundImg.src = 'images/sectors_upscaled_dimmed.png';
        backgroundImg.onload = () => drawPlanets();

        const biomeImageCache = new Map();

        const ownerColors = {
            "Humans": "cyan",
            "Automaton": "red",
            "Terminids": "yellow",
            "Illuminate": "purple"
        };

        const hideUnplayableMap = new Map();

        fetch('biomes.json').then(r => r.json()).then(biomes => {
            const biomeList = document.getElementById("biomeList");
            biomes.sort((a, b) => b.hippos - a.hippos);

            const defaultImg = new Image();
            defaultImg.src = "images/default.jpg";
            biomeImageCache.set("", defaultImg);

            const defaultBtn = document.createElement("div");
            defaultBtn.className = "biome selected";
            defaultBtn.dataset.name = "";
            const defaultImgElem = document.createElement("img");
            defaultImgElem.src = "images/default.jpg";
            defaultImgElem.alt = "All Biomes";
            defaultImgElem.title = "Show All Planets";
            defaultBtn.appendChild(defaultImgElem);

            const defaultToggleWrapper = document.createElement("div");
            defaultToggleWrapper.className = "toggle-wrapper";

            const defaultToggle = document.createElement("div");
            defaultToggle.className = "toggle off";
            defaultToggleWrapper.appendChild(defaultToggle);

            const defaultToggleCircle = document.createElement("div");
            defaultToggleCircle.className = "toggle-circle";
            defaultToggle.appendChild(defaultToggleCircle);

            const defaultUnplayableCircle = document.createElement("div");
            defaultUnplayableCircle.className = "unplayable-indicator";
            defaultToggleWrapper.appendChild(defaultUnplayableCircle);

            defaultBtn.appendChild(defaultToggleWrapper);

            const defaultHoverName = document.createElement("div");
            defaultHoverName.className = "hover-name";
            defaultBtn.appendChild(defaultHoverName);

            const defaultDots = document.createElement("div");
            defaultDots.className = "hippo-dots";
            const defaultDot = document.createElement("div");
            defaultDot.className = "hippo-dot";
            defaultDots.appendChild(defaultDot);
            defaultBtn.appendChild(defaultDots);

            biomeList.appendChild(defaultBtn);

            hideUnplayableMap.set("", false);
            biomes.forEach(b => hideUnplayableMap.set(b.name, false));

            function updateHoverName(div, biomeName) {
                const hide = hideUnplayableMap.get(biomeName);
                const baseText = biomeName === "" ? "All Biomes" : biomeName;
                div.querySelector(".hover-name").textContent = hide ? baseText + " (Only Playable Planets)" : baseText;
            }

            function updateToggle(div, biomeName) {
                const hide = hideUnplayableMap.get(biomeName);
                const toggle = div.querySelector(".toggle");
                if (!toggle) return;

                if (hide) {
                    toggle.classList.add("on");
                    toggle.classList.remove("off");
                } else {
                    toggle.classList.remove("on");
                    toggle.classList.add("off");
                }
            }

            updateHoverName(defaultBtn, "");
            updateToggle(defaultBtn, "");

            defaultBtn.addEventListener("click", () => {
                const biomeName = "";
                if (selectedBiome === null) {
                    const current = hideUnplayableMap.get(biomeName);
                    hideUnplayableMap.set(biomeName, !current);
                    updateHoverName(defaultBtn, biomeName);
                    updateToggle(defaultBtn, biomeName);
                    drawPlanets();
                } else {
                    selectedBiome = null;
                    updateSelection(defaultBtn);
                    updateHoverName(defaultBtn, biomeName);
                    updateToggle(defaultBtn, biomeName);
                    document.querySelectorAll(".biome").forEach(el => {
                        if (el !== defaultBtn) el.classList.remove("selected");
                    });
                    drawPlanets();
                }
            });


            biomes.forEach(biome => {
                const div = document.createElement("div");
                div.className = "biome";
                div.dataset.name = biome.name;

                const img = new Image();
                img.src = biome.image;
                biomeImageCache.set(biome.name, img);

                const imgElem = document.createElement("img");
                imgElem.src = biome.image;
                imgElem.alt = biome.name;
                imgElem.title = biome.name;

                div.appendChild(imgElem);

                const toggleWrapper = document.createElement("div");
                toggleWrapper.className = "toggle-wrapper";

                const toggle = document.createElement("div");
                toggle.className = "toggle off";
                toggleWrapper.appendChild(toggle);

                const toggleCircle = document.createElement("div");
                toggleCircle.className = "toggle-circle";
                toggle.appendChild(toggleCircle);

                const unplayableCircle = document.createElement("div");
                unplayableCircle.className = "unplayable-indicator";
                toggleWrapper.appendChild(unplayableCircle);

                div.appendChild(toggleWrapper);

                const hoverName = document.createElement("div");
                hoverName.className = "hover-name";
                div.appendChild(hoverName);

                const dotsContainer = document.createElement("div");
                dotsContainer.className = "hippo-dots";

                if (biome.hippos > 0) {
                    const count = Math.min(biome.hippos, 5);
                    for (let i = 0; i < count; i++) {
                        const dot = document.createElement("div");
                        dot.className = "hippo-dot yellow";
                        dotsContainer.appendChild(dot);
                    }
                } else {
                    const dot = document.createElement("div");
                    dot.className = "hippo-dot";
                    dotsContainer.appendChild(dot);
                }

                div.appendChild(dotsContainer);
                biomeList.appendChild(div);

                updateHoverName(div, biome.name);
                updateToggle(div, biome.name);

                div.addEventListener("click", () => {
                    const biomeName = biome.name;
                    if (selectedBiome !== biomeName) {
                        selectedBiome = biomeName;
                        updateSelection(div);
                        updateHoverName(div, biomeName);
                        updateToggle(div, biomeName);
                        defaultBtn.classList.remove("selected");
                        document.querySelectorAll(".biome").forEach(el => {
                            if (el !== div) el.classList.remove("selected");
                        });
                        drawPlanets();
                    } else {
                        const current = hideUnplayableMap.get(biomeName);
                        hideUnplayableMap.set(biomeName, !current);
                        updateHoverName(div, biomeName);
                        updateToggle(div, biomeName);
                        drawPlanets();
                    }
                });
            });

            function updateSelection(selectedDiv) {
                document.querySelectorAll(".biome").forEach(el => el.classList.remove("selected"));
                selectedDiv.classList.add("selected");
            }
        });


        async function loadPlanetsData() {
            if (devmode) {
                try {
                    const planets = await fetch('planets.json').then(r => r.json());
                    const playablePlanets = await fetch('playable_planets.json').then(r => r.json());

                    allPlanets = planets;
                    playablePlanetsSet = new Set(playablePlanets.map(p => p.planet.index));
                    drawPlanets();
                } catch (e) {
                    console.error("Failed to load local planets or playable_planets", e);
                }
            } else {
                try {
                    const randomId = Math.random().toString(36).substring(2, 10);
                    const planetsResp = await fetch('https://api.helldivers2.dev/api/v1/planets', {
                        headers: {
                            'accept': 'application/json',
                            'X-Super-Client': randomId,
                            'X-Super-Contact': randomId
                        }
                    });
                    const planets = await planetsResp.json();

                    const campaignsResp = await fetch('https://api.helldivers2.dev/api/v1/campaigns', {
                        headers: {
                            'accept': 'application/json',
                            'X-Super-Client': randomId,
                            'X-Super-Contact': randomId
                        }
                    });
                    const campaigns = await campaignsResp.json();

                    allPlanets = planets;
                    playablePlanetsSet = new Set(campaigns.map(c => c.planet.index));
                    drawPlanets();

                } catch (e) {
                    console.error("Failed to load planets or campaigns data", e);
                }
            }
        }

        loadPlanetsData();

        function clampOffset() {
            if (!canvas.width || !canvas.height) return;

            const margin = 500;
            const scaledWidth = canvas.width * scale;
            const scaledHeight = canvas.height * scale;

            const minOffsetX = Math.min(margin, canvas.width - scaledWidth - margin);
            const maxOffsetX = Math.max(margin, margin);

            const minOffsetY = Math.min(margin, canvas.height - scaledHeight - margin);
            const maxOffsetY = Math.max(margin, margin);

            if (scaledWidth <= canvas.width) {
                offsetX = Math.min(maxOffsetX, Math.max(minOffsetX, offsetX));
            } else {
                offsetX = Math.min(margin, Math.max(canvas.width - scaledWidth - margin, offsetX));
            }

            if (scaledHeight <= canvas.height) {
                offsetY = Math.min(maxOffsetY, Math.max(minOffsetY, offsetY));
            } else {
                offsetY = Math.min(margin, Math.max(canvas.height - scaledHeight - margin, offsetY));
            }
        }

        canvas.addEventListener("wheel", e => {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const wx = (mouseX - offsetX) / scale;
            const wy = (mouseY - offsetY) / scale;

            const zoomAmount = e.deltaY < 0 ? 1.1 : 0.9;
            scale *= zoomAmount;

            scale = Math.min(Math.max(scale, 0.5), 10);

            offsetX = mouseX - wx * scale;
            offsetY = mouseY - wy * scale;

            clampOffset();

            drawPlanets();
        }, { passive: false });

        canvas.addEventListener("mousedown", e => {
            isDragging = true;
            dragStartX = e.clientX - offsetX;
            dragStartY = e.clientY - offsetY;
            canvas.style.cursor = "grabbing";
        });
        window.addEventListener("mouseup", e => {
            isDragging = false;
            canvas.style.cursor = "grab";
        });
        window.addEventListener("mousemove", e => {
            if (isDragging) {
                offsetX = e.clientX - dragStartX;
                offsetY = e.clientY - dragStartY;
                clampOffset();
                drawPlanets();
            }
        });

        canvas.addEventListener("mousemove", e => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            hoveredPlanet = null;

            for (const planet of allPlanets) {
                if (selectedBiome && planet.biome.name !== selectedBiome) continue;
                const hideUnplayable = hideUnplayableMap.get(selectedBiome ?? "") ?? false;
                if (hideUnplayable && !playablePlanetsSet.has(planet.index)) continue;

                const x = ((planet.position.x + 1) / 2) * canvas.width * scale + offsetX;
                const y = (1 - ((planet.position.y + 1) / 2)) * canvas.height * scale + offsetY;

                const dx = mouseX - x;
                const dy = mouseY - y;

                if (Math.sqrt(dx * dx + dy * dy) <= planetRadius * scale) {
                    hoveredPlanet = planet;
                    break;
                }
            }

            drawPlanets();
        });

        let lastTouchDist = null;
        let lastTouchCenter = null;
        let isTouchPanning = false;

        canvas.addEventListener("touchstart", e => {
            if (e.touches.length === 1) {
                isDragging = true;
                dragStartX = e.touches[0].clientX - offsetX;
                dragStartY = e.touches[0].clientY - offsetY;
                isTouchPanning = true;
            } else if (e.touches.length === 2) {
                isDragging = false;
                isTouchPanning = false;
                lastTouchDist = getTouchDist(e.touches);
                lastTouchCenter = getTouchCenter(e.touches);
            }
        }, { passive: false });

        canvas.addEventListener("touchmove", e => {
            e.preventDefault();
            if (e.touches.length === 1 && isTouchPanning) {
                offsetX = e.touches[0].clientX - dragStartX;
                offsetY = e.touches[0].clientY - dragStartY;
                clampOffset();
                drawPlanets();
            } else if (e.touches.length === 2) {
                const newDist = getTouchDist(e.touches);
                const newCenter = getTouchCenter(e.touches);

                if (lastTouchDist && lastTouchCenter) {
                    const zoomAmount = newDist / lastTouchDist;
                    const newScale = Math.min(Math.max(scale * zoomAmount, 0.5), 10);

                    const wx = (newCenter.x - offsetX) / scale;
                    const wy = (newCenter.y - offsetY) / scale;

                    scale = newScale;

                    offsetX = newCenter.x - wx * scale;
                    offsetY = newCenter.y - wy * scale;

                    clampOffset();
                    drawPlanets();
                }

                lastTouchDist = newDist;
                lastTouchCenter = newCenter;
                isTouchPanning = false;
            }
        }, { passive: false });

        canvas.addEventListener("touchend", e => {
            if (e.touches.length < 2) {
                lastTouchDist = null;
                lastTouchCenter = null;
            }
            if (e.touches.length === 0) {
                isDragging = false;
                isTouchPanning = false;
            }
        });

        function getTouchDist(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchCenter(touches) {
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };
        }

        function drawPlanets() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
            ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
            ctx.restore();

            const hideUnplayable = hideUnplayableMap.get(selectedBiome ?? "") ?? false;

            allPlanets
                .filter(planet => {
                    if (selectedBiome && planet.biome.name !== selectedBiome) return false;
                    if (hideUnplayable && !playablePlanetsSet.has(planet.index)) return false;
                    return true;
                })

                .forEach(planet => {
                    const x = ((planet.position.x + 1) / 2) * canvas.width * scale + offsetX;
                    const y = (1 - ((planet.position.y + 1) / 2)) * canvas.height * scale + offsetY;

                    ctx.beginPath();
                    ctx.arc(x, y, planetRadius * scale, 0, Math.PI * 2);

                    const isPlayable = playablePlanetsSet.has(planet.index);
                    ctx.fillStyle = isPlayable
                        ? (ownerColors[planet.currentOwner] || "white")
                        : "grey";

                    ctx.fill();

                    ctx.fillStyle = isPlayable ? "white" : "#777";
                    ctx.font = `${12 * scale}px Arial`;
                    ctx.textBaseline = "alphabetic";
                    ctx.fillText(planet.name, x + 10 * scale, y + 4 * scale);
                });

            if (hoveredPlanet) {
                drawPopup(hoveredPlanet);
            }
        }

        function drawPopup(planet) {
            const x = ((planet.position.x + 1) / 2) * canvas.width * scale + offsetX;
            const y = (1 - ((planet.position.y + 1) / 2)) * canvas.height * scale + offsetY;

            const padding = 10 * scale;
            const imgWidth = 140 * scale;
            const imgHeight = 60 * scale;

            const textHeight = 24 * scale;
            const boxWidth = imgWidth + padding * 2;
            const boxHeight = imgHeight + textHeight + padding * 2;
            const radius = 10 * scale;

            ctx.fillStyle = "rgba(0, 122, 204, 0.8)";
            roundRect(ctx, x + 15 * scale, y - boxHeight / 2, boxWidth, boxHeight, radius);
            ctx.fill();

            ctx.fillStyle = "white";
            ctx.font = `bold ${16 * scale}px Arial`;
            ctx.textBaseline = "top";
            ctx.fillText(planet.biome.name, x + 15 * scale + padding, y - boxHeight / 2 + padding);

            const img = biomeImageCache.get(planet.biome.name);
            if (img && img.complete) {
                ctx.drawImage(img, x + 15 * scale + padding, y - boxHeight / 2 + padding + textHeight, imgWidth, imgHeight);
            }
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
    </script>

</body>

</html>